// 1. Почитать про принципы программирования KISS, DRY, YAGNI + почитать про "Антипаттерны" чистого кода;

// KISS (Keep It Simple, Stupid);
// Этот принцип предлагает делать решения как можно более простыми и понятными.
// Простота в проектировании и коде облегчает поддержку, понимание и развитие программы.
// Сложные решения могут вести к трудностям в поддержке и добавлению нового функционала.

// DRY (Don't Repeat Yourself);
// Принцип DRY подчеркивает необходимость избегать дублирования кода.
// Если у вас есть повторяющийся код, лучше вынести общую логику в отдельные функции, классы или модули.
// Это не только уменьшает объем кода, но также облегчает его изменение в будущем.

// YAGNI (You Ain't Gonna Need It);
// Не следует добавлять функционал, который в данный момент не требуется.
// Следует избегать добавления "запасных" или предвосхищающих будущее функций без явной необходимости,
// так как они могут усложнить код и внести дополнительные проблемы.

// Антипаттерны (Antipatterns);
// Это образцы проектирования, которые кажутся хорошей идеей, но на практике приводят к проблемам.
// Примеры:  "Magic Object", "Singleton", "Magic Object" (захардхоженные строки), "Golden Hammer)".
// Также антипаттерны: "Spaghetti code", "Boat anchor", "Dead code"

// 2. Прочитать про способы хранения LocalStorage, SessionStorage и Cookie;

// Это три различных механизма хранения данных в веб-браузере.
// Они предоставляют возможность веб-приложениям сохранять и получать данные на стороне клиента,
// чтобы обеспечить постоянство информации между различными запросами и перезапусками браузера.

// LocalStorage:
// Хранение: Позволяет хранить данные в виде пар ключ-значение в локальном хранилище браузера.
// Жизненный цикл: Данные в LocalStorage остаются сохраненными даже после закрытия браузера и перезапуска компьютера.
// Объем данных: Обычно предоставляет более высокий объем хранения (обычно 5-10 МБ), чем Cookies.
// Доступ: JavaScript может легко получать и изменять данные в LocalStorage.

// Сохранение данных в LocalStorage;
localStorage.setItem('key', 'value');

// Получение данных из LocalStorage;
const localValue = localStorage.getItem('key');

// SessionStorage:

// Хранение: Подобно LocalStorage, но данные в SessionStorage доступны только в течение текущей сессии браузера.
// Жизненный цикл: Данные в SessionStorage удаляются после закрытия вкладки или браузера.
// Объем данных: Обычно предоставляет тот же объем хранения, что и LocalStorage (5-10 МБ).
// Доступ: JavaScript может легко получать и изменять данные в SessionStorage.

// Сохранение данных в SessionStorage;
sessionStorage.setItem('key', 'data');

// Получение данных из SessionStorage;
const sessionValue = sessionStorage.getItem('key');

// Cookies:

// Хранение: Это небольшие строки данных, хранятся в виде пар ключ=значение; в браузере и отправляются на сервер с каждым HTTP-запросом.
// Они являются частью HTTP-протокола.
// Куки обычно устанавливаются веб-сервером при помощи заголовка Set-Cookie.

// Жизненный цикл: Может иметь определенный срок годности (устанавливается с помощью атрибута expires или max-age), после которого cookie удаляется.
// Объем данных: Ограничен по размеру (обычно около 4 КБ на домен и 20 куки на домен).
// URL-префикс пути, куки будут доступны для страниц под этим путём. Должен быть абсолютным. По умолчанию используется текущий путь.
// path=/ - для всех страниц сайта.
// domain=site.com - определяет гду доступен файл cookie. По умолчанию куки доступны лишь тому домену, который его установил.
// Если явно установить domain=site.com, то мы откроем доступ к cookie к поддоменам.
// secure - куки будут доступны только по https.
// expires, max-age - если не установлено, то куки удаляться при закрытии браузера.
// Доступ: JavaScript имеет доступ к данным cookie через API Document.

// Установка cookie;
document.cookie = 'key=value; user=John; expires=Wed, 21 Dec 2022 12:00:00 UTC; path=/';

// обновляем только куки с именем 'user', но не тронет другие значения;
document.cookie = "user=John";

// Получение всех cookie;
const allCookies = document.cookie;

// 3. HTML / CSS - Базовая структура html документа;

// 1- <!DOCTYPE html> Определяет версию HTML, которую использует документ (в данном случае, HTML5);
// 2. <html lang="en"> Определяет начало документа и язык;
// 3. <head> Содержит метаданные (кодировка, viepoint для оптимизации масштабирования страницы), здесь подключаются стили, указывается title вкладки браузера;
// 4. <body> Здесь содержимое вашей веб-страницы и разметка;


// БЭМ методология;

// Блок (Block): независимый компонент веб-интерфейса. Отвечает на вопрос: "что это?", а не "какой он?""
// Это может быть любой элемент страницы, который имеет смысл как отдельный компонент. Например, "header", "menu", "button".

// Блок не должен влиять на свое окружение, т.е. блоку не следует задавать внешнюю геометрию
//(в виде отступов, границ, влияющих на размеры) и позиционирование.

{/* <div class="blok-name"></div> */}

// Элемент (Element): является частью блока и не имеет смысла вне контекста этого блока. Также отвечает на вопрос: "что это?"", а не "какой он"?
// Элементы должны быть описаны как "имя-блока__имя-элемента".
// Элементы могут быть вложенны друг в друга, досдны принадледать "своему" блоку, они являются необязательными.

{/* <div class="block">
    <span class="blok-name__element"></span>
</div> */}

// Модификатор (Modifier): используются для изменения стиля, внешнего вида или поведения блока или элемента.
// Отвечает на вопросЖ "какой?" и т. п. — "размер", «тема», disabled, focused, directions_left-top.
// Имя модификатора отделяется от имени блока или элемента одним подчеркиванием (_).

{/* <div class="block block_mod-value"></div>
<div class="blok-name__element blok-name__element_mod-value"></div> */}


// 4. Почитать про паттерны функционального программирования + посмотреть примеры использования;
// Функциональное программирование — это парадигма, в которой программы строятся на основе функций.

// КЛЮЧЕВЫЕ ПОНЯТИЯ:
// * Использование функций высшего порядка (Higher-Order Functions);
// * Использование замыканий (Closures);
// * Принцим неизменяемости входных данных (Immutability);
// * Понятие "чистой" функции (Pure Functions), отделение от функций с "побочными эффектами";
// * Использование рекурсии  (Recursion);
// * Использование композиции (Function Composition);

// 5. Способы позиционирования контента на странице;
// Позиционирование контента на веб-странице в HTML и CSS может быть реализовано различными способами. 

// При помощи CSS свойства position;

// static - по-усолчанию;
// absolute - позиционирование элемента относительно ближайшего спозиционированного радителя (не static),
// элемент находится не в потоке;
// relative - элемент остётся в потоке документа, сдвигается отноститьно своего нармального местоположения;
// fixed - элемент не в потоке, фиксируется в определенной части экрана прокрутки;
// stycky - применяется в рамках блока, а не всего документа;

// При помощи Flexbox;

// При помощи Grid;

// При помощи Float;
// Плаващий поток. Делает элементы блочными. Браузер автоматически сдвигает текст к границе плавающего потока;

// 6. Веса селекторов;
// В CSS вес селектора определяет его специфичность,
// то есть приоритет в применении стилей к элементам.
// Специфичность измеряется числами и определяется по количеству элементов, классов и идентификаторов в селекторе.

// Вес селектора записывается в виде четырех чисел (a, b, c, d), где:

// a - количество идентификаторов в селекторе;
// b - количество классов, псевдоклассов(:hover), селекторов атрибутов([type="text"]);
// c - количество элементов, псевдоэлементов(::before) в селекторе;
// d - вес важности (например, !important);

//  (1, 0, 3, 0) > (0, 3, 3, 0);
// inline стили - (1, 0, 0, 0);

// Если стили применяются к одному и тому же элементу с использованием нескольких правил,
// то применяются правила с более высоким весом. Если вес совпадает, то применяется тот стиль, который определен последним.



