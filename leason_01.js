// 1. Метод OPTIONS
// это HTTP-метод, который используется для определения возможностей сервера или параметров соединения для конкретного ресурса.
// Этот метод предоставляет клиенту информацию о поддерживаемых методах запроса, типах содержимого, поддерживаемых заголовках
// и других аспектах ресурса.
// Используется для предзапросов Preflight по технологии CORS.

// 2. Ключевые особенности HTTP 3.0
// * использование нового транспортного протокола QUIC
// * в основе - транспортный протокол UDP
// * быстрое установлениие соединения (оптимизированное установление соединения без избыточного обмена протоколами)
// * настройка безопасного соединения с помощью SSL и TLS
// * новый механизм сжатия заголовков QPACK
// * умеет гибко реагировать на изменение пропускной способности или задержки сети
// * успользует усовершенствованный механизм восстановления после потерь и прямое исправление ошибок


// 3. Cпособы отмены запроса, включая объект "AbortController"
// * Для библиотеки fetch
// Для отмены запроса вызывается метод abort() объекта AbortController.
// const controller = new AbortController();
// fetch('/api/data', { signal: controller.signal })
//   .then(res => {});
// controller.abort();

// Для библиотеки axios
// Для отмены запроса вызывается метод cancel() объекта CancelToken.
// axios вторым параметром ожидает токен для отмены запроса
// const source = axios.CancelToken.source();
// axios.get('/api/data', { cancelToken: source.token })
// .then(res => {});
// source.cancel('cancel messsage');

// 4. Написать по 2 примера создания примитивных значений
// (если есть несколько способов - использовать) (string, number, boolean, null, undefined, symbol, bigInt)

const myString = 'this is a string';
const anotherString = String('another string');

const myNumber = 7;
const anotherNumber = Number(7);

const myFalse = Boolean(null);
const meTrue = Boolean(5);
const anotherTrue = true;


const myNull = null;

const meUndefined = undefined;

const mySymbol = Symbol(150);
const sym2 = Symbol.for('hi');

const myBigint = 475869n;
const anotherBgint = BigInt('145463748590675675');

// Почему, если обратиться к переменным созданным через let, const до их объявления - мы получаем ReferenceError?
// => Это происходит потому. что переменные всплавают во временной мертовой зоне - Temporal Dead Zone.
// Temporal Dead Zone - это период во время исполнения кода, в течение которого переменная уже существует (ее объявление было произведено),
// но до того, как ей было присвоено значение. 

// 5. Решить
const res = "B" + "a" + (1 - "hello");
console.log(res); // BaNaN
// => выполняется конкатенация строк "B" и "a" и третьего вычисляемого значения, которое приводится к строке =>
// => результат выражения (1 - "hello") = NaN, так как происходит преобразование строки "hello" к числу и возвращает NaN =>
// NaN приводится к строке 'NaN' при помощи метода toString();

const res2 = (true && 3) + "d";
console.log(res2);// 3d
// => оператор && возвращает последнее истинное значение - это 3
// => число 3 приводится к строке в результате конкатенации со строкой "d"

const res3 = Boolean(true && 3) + "d";
console.log(res3); // trued
// (true && 3) возвращает последнее истинное значение, поэтому это будет 3
// => Boolean(3) вернет true
// => true будет приведено к строке, так как происходит конкатенация